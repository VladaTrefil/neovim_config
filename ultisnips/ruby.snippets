# ────────────────────────────────────────────────────────────────────────────────────────────────────
#   Reference: {{{

# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt

#   }}}
# ────────────────────────────────────────────────────────────────────────────────────────────────────

#                   __
#                  /\ \
#     _ __   __  __\ \ \____  __  __
#    /\`'__\/\ \/\ \\ \ '__`\/\ \/\ \
#    \ \ \/ \ \ \_\ \\ \ \L\ \ \ \_\ \
#     \ \_\  \ \____/ \ \_,__/\/`____ \
#      \/_/   \/___/   \/___/  `/___/> \
#                                 /\___/
#                                 \/__/


priority -50

snippet frozen "frozen string literal" b
# frozen_string_literal: true
endsnippet

snippet require "require" b
require '${1}'
endsnippet

snippet include "include" b
include ${1}
endsnippet

snippet def "def <name>..." b
def ${1:function_name}${2:(${3:*args})}
	$0
end
endsnippet

snippet each "each { |i| <block> }"
each { |${1:i}| $0 }
endsnippet

snippet each:do "each do |i| <block>"
each do |${1:i}|
	$0
end
endsnippet

snippet map "map { |i| <block> }" w
map { |${1:i}| $0 }
endsnippet

snippet map:pluck "mp" w
map(&:${1:id})
endsnippet

snippet map:do "map do |i| <block>" w
map do |${1:i}|
	$0
end
endsnippet

snippet sort "sort()"
sort { |a, b| ${1} }
endsnippet

snippet sort:by "sort_by()"
sort_by { |${1:e}| ${2} }
endsnippet

snippet each_pair "each_pair { |i| <block> }"
each_pair { |${1:i}| $0 }
endsnippet

snippet each_pairdo "each_pair do |i| <block>"
each_pair do |${1:i}|
	$0
end
endsnippet

snippet find "find()"
find { |${1:e}| ${2} }
endsnippet

snippet find:do "find do"
find do |${1:e}|
	${2}
end
endsnippet

snippet find:all "find_all()"
find_all { |${1:e}| ${2} }
endsnippet

snippet find:all_do "finad"
find_all do |${1:e}|
	${2}
end
endsnippet

snippet max "max"
max { |a, b| ${1} }
endsnippet

snippet min "min"
min { |a, b| ${1} }
endsnippet

snippet partition "partition"
partition { |${1:e}| ${2} }
endsnippet

snippet partition:do "partition do"
partition do |${1:e}|
	${2}
end
endsnippet

snippet reject "reject()"
reject { |${1:e}| ${2} }
endsnippet

snippet reject:do "reject do"
reject do |${1:e}|
	${2}
end
endsnippet

snippet select "select()"
select { |${1:e}| ${2} }
endsnippet

snippet select:do "select do"
select do |${1:e}|
	${2}
end
endsnippet

snippet for "for"
for ${1} in ${2}
	${3}
end
endsnippet

snippet until "until <expression> ... end" b
until ${1:expression}
	$0
end
endsnippet

snippet while "while <expression> ... end" b
while ${1:expression}
	$0
end
endsnippet

snippet case "case <variable> when <expression> ... end" b
case ${1:variable}
when ${2:expression}
	$0
end
endsnippet

snippet class "class" b
class ${1}
	${0}
end
endsnippet

snippet class:child "class child" b
class ${1} < ${2:Application}
	${0}
end
endsnippet

snippet if "if"
if ${1}
	${0}
end
endsnippet

snippet ife "if, else"
if ${1}
	${2}
else
	${0}
end
endsnippet

snippet ifei "if, else if, else"
if ${1}
	${2}
elsif ${3}
	${4}
else
	${0}
end
endsnippet

snippet elif "else if" b
elsif ${1}
	${0}
endsnippet

snippet module "module"
module ${1}
	$0
end
endsnippet

snippet ivc "instance variable" b
@${1:variable_name} ||= ${0:cached_value}
endsnippet

snippet assert "assert"
assert ${1:test}, "${2:Failure message.}"${3}
endsnippet

snippet assert:equal "assert_equal"
assert_equal ${1:expected}, ${2:actual}${3}
endsnippet

snippet assert:not_equal "assert_not_equal"
assert_not_equal ${1:unexpected}, ${2:actual}${3}
endsnippet

snippet assert:delta "assert_in_delta"
assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2 ** -20}${4}
endsnippet

snippet assert:instance "assert_instance_of"
assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}${3}
endsnippet

snippet assert:kind "assert_kind_of"
assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}${3}
endsnippet

snippet asn "asn"
assert_nil ${1:instance}${2}
endsnippet

snippet asnn "asnn"
assert_not_nil ${1:instance}${2}
endsnippet

snippet asm "asm"
assert_match /${1:expected_pattern}/, ${2:actual_string}${3}
endsnippet

snippet asnm "asnm"
assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}${3}
endsnippet

snippet aso "aso"
assert_operator ${1:left}, :${2:operator}, ${3:right}${4}
endsnippet

snippet asr "asr"
assert_raise ${1:Exception} { ${2} }
endsnippet

snippet asrd "asrd"
assert_raise ${1:Exception} do
	${2}
end
endsnippet

snippet asnr "asnr"
assert_nothing_raised ${1:Exception} { ${2} }
endsnippet

snippet asnrd "asnrd"
assert_nothing_raised ${1:Exception} do
	${2}
end
endsnippet

snippet asrt "asrt"
assert_respond_to ${1:object}, :${2:method}${3}
endsnippet

snippet ass "assert_same(..)"
assert_same ${1:expected}, ${2:actual}${3}
endsnippet

snippet ass "assert_send(..)"
assert_send [${1:object}, :${2:message}, ${3:args}]${4}
endsnippet

snippet asns "asns"
assert_not_same ${1:unexpected}, ${2:actual}${3}
endsnippet

snippet ast "ast"
assert_throws :${1:expected} { ${2} }
endsnippet

snippet astd "astd"
assert_throws :${1:expected} do
	${2}
end
endsnippet

snippet asnt "asnt"
assert_nothing_thrown { ${1} }
endsnippet

snippet asntd "asntd"
assert_nothing_thrown do
	${1}
end
endsnippet

snippet stim:controller "controller"
stimulus_controller("i-leads-form", values:)
endsnippet

# TODO: turn 'button' into 'onButtonClick'
snippet stim:action "action"
stimulus_action(${1:click}: ${0:onClick})
endsnippet

snippet stim:target "target"
stimulus_target("${0}")
endsnippet

snippet bem "Component bem_class_name"
bem_class_name :${0}
endsnippet

extends rails
extends folio
